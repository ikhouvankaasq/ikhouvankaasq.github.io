<!DOCTYPE html>
<html>
<head>
    <title>Game Paradise - Paper.io Pixel</title>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Nunito:wght@700;900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/icon/favicon.png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html { overflow: hidden; font-family: 'Nunito', sans-serif; }
        canvas { display: block; background: #1a1a2e; }
        
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            color: white; 
            z-index: 10;
            overflow: hidden;
        }

        #ui-overlay.theme-original {
            background: #2e3331;
        }

        #bg-animation {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.3;
            z-index: 0;
            pointer-events: none;
        }

        .menu-content {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .game-title {
            font-family: 'Russo One', sans-serif;
            font-size: 72px;
            color: white;
            text-shadow: 
                4px 4px 0px #e74c3c,
                8px 8px 0px rgba(0,0,0,0.2);
            letter-spacing: 4px;
            animation: titleBounce 2s ease-in-out infinite;
        }

        .game-title span { color: #ffd32a; }

        .game-logo {
            display: none;
            max-width: 350px;
            height: auto;
            animation: titleBounce 2s ease-in-out infinite;
        }

        .theme-original .game-title {
            display: none;
        }

        .theme-original .game-logo {
            display: block;
        }

        .theme-original .subtitle {
            display: none;
        }

        @keyframes titleBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .subtitle {
            font-size: 18px;
            color: rgba(255,255,255,0.8);
            margin-top: -10px;
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        #player-name {
            width: 280px;
            padding: 18px 25px;
            font-size: 20px;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            background: white;
            color: #333;
            text-align: center;
            outline: none;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .button-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #start-btn {
            padding: 20px 80px;
            font-size: 28px;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            cursor: pointer;
            background: linear-gradient(180deg, #00d2d3 0%, #0abf9a 100%);
            color: white;
            border: none;
            border-radius: 50px;
            box-shadow: 0 8px 0 #099c7d, 0 15px 30px rgba(0,0,0,0.3);
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #start-btn:hover { transform: translateY(-3px); }
        #start-btn:active { transform: translateY(4px); }

        #settings-btn {
            width: 60px;
            height: 60px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }

        #settings-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: brightness(0) invert(1);
        }

        #settings-btn:hover { 
            background: rgba(255,255,255,0.3);
            transform: rotate(45deg);
        }

        .stats-container { display: flex; gap: 30px; margin-top: 20px; }
        .stat-box {
            background: rgba(255,255,255,0.15);
            padding: 15px 30px;
            border-radius: 15px;
            text-align: center;
        }
        .stat-box .value { font-size: 28px; font-weight: 900; color: #ffd32a; }
        .stat-box .label { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.8; }

        /* Settings Panel */
        #settings-panel {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #2d2d44 0%, #1a1a2e 100%);
            padding: 0;
            border-radius: 20px;
            z-index: 100;
            min-width: 380px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .settings-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .settings-header img {
            width: 32px;
            height: 32px;
            filter: brightness(0) invert(1);
        }

        .settings-header h2 {
            margin: 0;
            font-size: 24px;
            color: white;
        }

        .settings-tabs {
            display: flex;
            background: rgba(0,0,0,0.3);
            padding: 0;
        }

        .settings-tab {
            flex: 1;
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            font-family: 'Nunito', sans-serif;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 3px solid transparent;
        }

        .settings-tab:hover {
            color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.05);
        }

        .settings-tab.active {
            color: #00d2d3;
            border-bottom-color: #00d2d3;
            background: rgba(0,208,211,0.1);
        }

        .settings-content {
            padding: 25px 30px;
            min-height: 280px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 18px 0;
            color: white;
        }

        .setting-row label {
            font-size: 15px;
            font-weight: 700;
        }

        .setting-row input[type="range"] {
            width: 100px;
            cursor: pointer;
            accent-color: #00d2d3;
        }

        .setting-row .value-display {
            min-width: 40px;
            text-align: right;
            color: #00d2d3;
            font-weight: 900;
        }

        .setting-row select {
            padding: 8px 15px;
            border-radius: 10px;
            border: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            cursor: pointer;
            background: rgba(255,255,255,0.9);
        }

        .setting-row input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        .theme-colors {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .theme-color-btn {
            width: 45px;
            height: 45px;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-color-btn:hover {
            transform: scale(1.1);
        }

        .theme-color-btn.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        .theme-section {
            margin-bottom: 20px;
        }

        .theme-section-title {
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        /* Start Screen Theme Selection */
        .screen-theme-options {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .screen-theme-btn {
            flex: 1;
            padding: 15px;
            border-radius: 12px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .screen-theme-btn:hover {
            transform: scale(1.02);
        }

        .screen-theme-btn.selected {
            border-color: #00d2d3;
            box-shadow: 0 0 20px rgba(0,208,211,0.4);
        }

        .screen-theme-btn .theme-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .screen-theme-btn.theme-standard .theme-preview {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .screen-theme-btn.theme-original .theme-preview {
            background: #2e3331;
        }

        .screen-theme-btn .theme-preview-text {
            font-family: 'Russo One', sans-serif;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 0px #e74c3c;
        }

        .screen-theme-btn .theme-preview-text span {
            color: #ffd32a;
        }

        .screen-theme-btn .theme-preview img {
            max-height: 40px;
            width: auto;
        }

        .screen-theme-btn .theme-name {
            color: white;
            font-size: 14px;
            font-weight: 700;
        }

        .account-section {
            text-align: center;
            padding: 20px 0;
        }

        .account-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
            font-weight: 900;
        }

        .account-name {
            color: white;
            font-size: 20px;
            font-weight: 900;
            margin-bottom: 5px;
        }

        .account-stats {
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .account-btn {
            padding: 10px 25px;
            margin: 5px;
            font-size: 14px;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            cursor: pointer;
            border: none;
            border-radius: 20px;
            transition: all 0.2s;
        }

        .account-btn.primary {
            background: linear-gradient(180deg, #00d2d3 0%, #0abf9a 100%);
            color: white;
        }
        
        .account-btn.google-btn {
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px auto;
        }

        .account-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .account-btn:hover {
            transform: scale(1.05);
        }

        .cloud-sync-info {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,208,211,0.1);
            border-radius: 12px;
            border: 1px solid rgba(0,208,211,0.3);
            text-align: left;
        }

        .cloud-sync-info .sync-title {
            color: #00d2d3;
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .cloud-sync-info .sync-detail {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
            line-height: 1.6;
        }

        #close-settings {
            display: block;
            width: calc(100% - 60px);
            padding: 15px;
            margin: 0 30px 25px;
            font-size: 16px;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            cursor: pointer;
            background: linear-gradient(180deg, #00d2d3 0%, #0abf9a 100%);
            color: white;
            border: none;
            border-radius: 30px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #close-settings:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(0,208,211,0.4);
        }

        #settings-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 99;
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 5;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 30px;
            border-radius: 25px;
            font-size: 24px;
            font-weight: 900;
            z-index: 5;
            display: none;
        }

        #leaderboard {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 5;
            display: none;
            min-width: 150px;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }

        .leaderboard-entry {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .leaderboard-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .leaderboard-name {
            flex: 1;
        }

        .leaderboard-score {
            font-weight: bold;
        }

        /* In-game settings button */
        #ingame-settings {
            position: absolute;
            top: 20px;
            left: auto;
            right: 20px;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 50%;
            z-index: 6;
            display: none;
            transition: all 0.2s;
        }

        #ingame-settings:hover {
            background: rgba(0,0,0,0.7);
            transform: rotate(45deg);
        }

        /* Pause overlay */
        #pause-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 50;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #pause-overlay h2 {
            font-size: 48px;
            margin-bottom: 30px;
        }

        #pause-overlay button {
            padding: 15px 50px;
            margin: 10px;
            font-size: 20px;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            cursor: pointer;
            border: none;
            border-radius: 30px;
            transition: all 0.2s;
        }

        #resume-btn {
            background: linear-gradient(180deg, #00d2d3 0%, #0abf9a 100%);
            color: white;
        }

        #quit-btn {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        #resume-btn:hover, #quit-btn:hover {
            transform: scale(1.05);
        }

        /* Skins Button Styles */
        .skins-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px 35px;
            font-size: 18px;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            cursor: pointer;
            background: linear-gradient(180deg, #ff6b6b 0%, #ee5a5a 100%);
            color: white;
            border: none;
            border-radius: 50px;
            box-shadow: 0 6px 0 #c74444, 0 10px 20px rgba(0,0,0,0.2);
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 15px;
        }

        .skins-btn img {
            width: 24px;
            height: 24px;
            filter: brightness(0) invert(1);
        }

        .skins-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 9px 0 #c74444, 0 15px 25px rgba(0,0,0,0.25);
        }

        .skins-btn:active {
            transform: translateY(3px);
            box-shadow: 0 3px 0 #c74444, 0 5px 10px rgba(0,0,0,0.2);
        }

        /* In-game skins button */
        .skins-btn.ingame {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 14px;
            margin-top: 0;
            z-index: 5;
            display: none;
            background: rgba(0,0,0,0.5);
            box-shadow: none;
            border-radius: 25px;
        }

        .skins-btn.ingame img {
            width: 20px;
            height: 20px;
        }

        .skins-btn.ingame:hover {
            background: rgba(0,0,0,0.7);
            transform: none;
            box-shadow: none;
        }

        .skins-btn.ingame:active {
            transform: scale(0.95);
            box-shadow: none;
        }

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: 700;
        }

        #loading-details {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Connecting to cloud...</div>
        <div id="loading-details"></div>
    </div>

    <div id="ui-overlay">
        <canvas id="bg-animation"></canvas>
        
        <div class="menu-content">
            <div class="game-title">PAPER<span>.IO</span></div>
            <img class="game-logo" src="https://jappie716.github.io/games/paper-io-pixel/images/paperiopixellogo.png" alt="Paper.io Pixel">
            <div class="subtitle">Conquer the map</div>
            <input type="text" id="player-name" placeholder="Enter your name" maxlength="15">
            <div class="button-row">
                <button id="start-btn">Play!</button>
                <button id="settings-btn">
                    <img src="https://jappie716.github.io/games/paper-io-pixel/images/settings.png" alt="Settings">
                </button>
            </div>
            <div class="stats-container">
                <div class="stat-box">
                    <div class="value" id="high-score">0%</div>
                    <div class="label">Best Score</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="games-played">0</div>
                    <div class="label">Games</div>
                </div>
            </div>
            <button id="menu-skins-btn" class="skins-btn">
                <img src="https://jappie716.github.io/games/paper-io-pixel/images/skins.png" alt="Skins">
                <span>Skins</span>
            </button>
        </div>
    </div>

    <div id="settings-overlay"></div>
    <div id="settings-panel">
        <div class="settings-header">
            <img src="https://jappie716.github.io/games/paper-io-pixel/images/settings.png" alt="Settings">
            <h2>Settings</h2>
        </div>
        
        <div class="settings-tabs">
            <button class="settings-tab active" data-tab="game">Game</button>
            <button class="settings-tab" data-tab="theme">Theme</button>
            <button class="settings-tab" data-tab="account">Account</button>
        </div>
        
        <div class="settings-content">
            <div class="tab-content active" id="tab-game">
                <div class="setting-row">
                    <label>Bot Count</label>
                    <input type="range" id="setting-bots" min="1" max="20" value="10">
                    <span class="value-display" id="bots-value">10</span>
                </div>
                <div class="setting-row">
                    <label>Game Speed</label>
                    <input type="range" id="setting-speed" min="1" max="10" value="5">
                    <span class="value-display" id="speed-value">5</span>
                </div>
                <div class="setting-row">
                    <label>Zoom Level</label>
                    <input type="range" id="setting-zoom" min="10" max="30" value="18">
                    <span class="value-display" id="zoom-value">1.8x</span>
                </div>
                <div class="setting-row">
                    <label>Map Size</label>
                    <select id="setting-mapsize">
                        <option value="1500">Small</option>
                        <option value="2000" selected>Medium</option>
                        <option value="3000">Large</option>
                    </select>
                </div>
            </div>
            
            <div class="tab-content" id="tab-theme">
                <div class="theme-section">
                    <div class="theme-section-title">Start Screen Theme</div>
                    <div class="screen-theme-options">
                        <button class="screen-theme-btn theme-standard selected" data-screen-theme="standard">
                            <div class="theme-preview">
                                <div class="theme-preview-text">PAPER<span>.IO</span></div>
                            </div>
                            <div class="theme-name">Standard</div>
                        </button>
                        <button class="screen-theme-btn theme-original" data-screen-theme="original">
                            <div class="theme-preview">
                                <img src="https://jappie716.github.io/games/paper-io-pixel/images/paperiopixellogo.png" alt="Original">
                            </div>
                            <div class="theme-name">Original</div>
                        </button>
                    </div>
                </div>
                <div class="theme-section">
                    <div class="theme-section-title">Player Color</div>
                    <div class="theme-colors" id="player-colors">
                        <button class="theme-color-btn selected" style="background: #ff4757;" data-color="#ff4757"></button>
                        <button class="theme-color-btn" style="background: #2ed573;" data-color="#2ed573"></button>
                        <button class="theme-color-btn" style="background: #1e90ff;" data-color="#1e90ff"></button>
                        <button class="theme-color-btn" style="background: #ffd32a;" data-color="#ffd32a"></button>
                        <button class="theme-color-btn" style="background: #a55eea;" data-color="#a55eea"></button>
                        <button class="theme-color-btn" style="background: #ff6348;" data-color="#ff6348"></button>
                        <button class="theme-color-btn" style="background: #fd79a8;" data-color="#fd79a8"></button>
                        <button class="theme-color-btn" style="background: #00cec9;" data-color="#00cec9"></button>
                    </div>
                </div>
                <div class="theme-section">
                    <div class="theme-section-title">Custom Color</div>
                    <div class="setting-row">
                        <label>Pick your color</label>
                        <input type="color" id="setting-color" value="#ff4757">
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="tab-account">
                <div class="account-section">
                    <div class="account-avatar" id="account-avatar">?</div>
                    <div class="account-name" id="account-name">Guest Player</div>
                    <div class="account-stats">
                        <span id="account-games">0</span> games played • Best: <span id="account-best">0%</span>
                    </div>
                    <div>
                         <button class="account-btn google-btn" id="login-google-btn">
                            <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google" style="width:18px;height:18px;filter:none;">
                            Sign in with Google
                        </button>
                        <button class="account-btn secondary" id="reset-stats-btn">Reset Stats</button>
                    </div>
                    <div class="cloud-sync-info">
                        <div class="sync-title">☁️ Cloud Save Status</div>
                        <div class="sync-detail" id="cloud-sync-detail">Connecting...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <button id="close-settings">Save & Close</button>
    </div>

    <div id="pause-overlay">
        <h2>PAUSED</h2>
        <button id="resume-btn">Resume</button>
        <button id="quit-btn">Quit to Menu</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <canvas id="minimap" width="150" height="150"></canvas>
    <button id="ingame-settings">
        <img src="https://jappie716.github.io/games/paper-io-pixel/images/settings.png" alt="Settings" style="width: 24px; height: 24px; filter: brightness(0) invert(1);">
    </button>
    <button id="ingame-skins" class="skins-btn ingame">
        <img src="https://jappie716.github.io/games/paper-io-pixel/images/skins.png" alt="Skins">
        <span>Skins</span>
    </button>
    <div id="score-display">0%</div>
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-entries"></div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script>
// ==========================================
// FIREBASE CONFIGURATION & INITIALIZATION
// ==========================================
const firebaseConfig = {
    apiKey: "AIzaSyA0K4geAuueVfiItB_98-LkqRTnpYNUNvM",
    authDomain: "gameparadise-80490.firebaseapp.com",
    projectId: "gameparadise-80490",
    storageBucket: "gameparadise-80490.firebasestorage.app",
    messagingSenderId: "335620903527",
    appId: "1:335620903527:web:1bc1e01a386bf6e4e7fac2"
};

// Initialize Firebase
let firebaseApp = null;
let auth = null;
let db = null;
let currentUser = null;
let firebaseReady = false;

try {
    firebaseApp = firebase.initializeApp(firebaseConfig);
    auth = firebase.auth();
    db = firebase.firestore();
    console.log('Firebase initialized successfully');
} catch (error) {
    console.error('Firebase init failed: ' + error.message);
}

// ==========================================
// CLOUD SAVE MANAGER
// ==========================================
const CloudSave = {
    // Get user document reference - AANGEPAST VOOR JOUW RULES
    getUserDoc() {
        if (!currentUser || !db) return null;
        // Path: users/{userId}/saveData/paperio2
        return db.collection('users').doc(currentUser.uid).collection('saveData').doc('paperio2');
    },
    
    // Save data to cloud
    async save(data, silent = false) {
        if (!db || !currentUser) return false;
        
        const userDoc = this.getUserDoc();
        if (!userDoc) return false;
        
        try {
            if(!silent) document.getElementById('cloud-sync-detail').textContent = 'Saving...';
            
            // Structure the data for Firebase
            const saveData = {
                highScore: data.highScore || 0,
                gamesPlayed: data.gamesPlayed || 0,
                playerName: data.playerName || 'Guest',
                playerColor: data.playerColor || '#ff4757',
                unlockedSkins: data.unlockedSkins || ['default'],
                selectedSkin: data.selectedSkin || 'default',
                settings: data.settings || {},
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            await userDoc.set(saveData, { merge: true });
            
            if(!silent) {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                document.getElementById('cloud-sync-detail').textContent = '✅ Saved at ' + timeStr;
            }
            return true;
            
        } catch (error) {
            console.error('Save failed: ' + error.message);
            if(!silent) document.getElementById('cloud-sync-detail').textContent = 'Error saving';
            return false;
        }
    },
    
    // Load data from cloud
    async load() {
        if (!db || !currentUser) return null;
        const userDoc = this.getUserDoc();
        if (!userDoc) return null;
        
        try {
            const doc = await userDoc.get();
            if (doc.exists) {
                const rawData = doc.data();
                return {
                    highScore: rawData.highScore || 0,
                    gamesPlayed: rawData.gamesPlayed || 0,
                    playerName: rawData.playerName || '',
                    playerColor: rawData.playerColor || '#ff4757',
                    unlockedSkins: rawData.unlockedSkins || ['default'],
                    selectedSkin: rawData.selectedSkin || 'default',
                    settings: rawData.settings || {}
                };
            }
            return null;
        } catch (error) {
            console.error('Load failed: ' + error.message);
            return null;
        }
    },
    
    // Sync local and cloud data
    async syncData() {
        const cloudData = await this.load();
        const localData = getLocalSaveData();
        
        if (!cloudData && !localData) return getDefaultSaveData();
        
        // If logged in first time and no cloud data, upload local data
        if (!cloudData) {
            await this.save(localData, true);
            return localData;
        }
        
        // If we have cloud data, merge (take best scores)
        const mergedData = {
            highScore: Math.max(cloudData.highScore || 0, localData.highScore || 0),
            gamesPlayed: Math.max(cloudData.gamesPlayed || 0, localData.gamesPlayed || 0),
            playerName: cloudData.playerName || localData.playerName || '',
            playerColor: cloudData.playerColor || localData.playerColor || '#ff4757',
            unlockedSkins: [...new Set([...(cloudData.unlockedSkins || []), ...(localData.unlockedSkins || [])])],
            selectedSkin: cloudData.selectedSkin || 'default',
            settings: { ...cloudData.settings, ...localData.settings }
        };
        
        saveLocalData(mergedData);
        return mergedData;
    }
};

// ==========================================
// LOCAL STORAGE HELPERS
// ==========================================
function getLocalSaveData() {
    return {
        highScore: parseInt(localStorage.getItem('paperio_highscore') || '0'),
        gamesPlayed: parseInt(localStorage.getItem('paperio_games') || '0'),
        playerName: localStorage.getItem('paperio_name') || '',
        playerColor: localStorage.getItem('paperio_player_color') || '#ff4757',
        unlockedSkins: JSON.parse(localStorage.getItem('paperio_skins') || '["default"]'),
        selectedSkin: localStorage.getItem('paperio_selected_skin') || 'default',
        settings: JSON.parse(localStorage.getItem('paperio_settings') || '{}')
    };
}

function getDefaultSaveData() {
    return {
        highScore: 0,
        gamesPlayed: 0,
        playerName: '',
        playerColor: '#ff4757',
        unlockedSkins: ['default'],
        selectedSkin: 'default',
        settings: {}
    };
}

function saveLocalData(data) {
    if (data.highScore !== undefined) localStorage.setItem('paperio_highscore', data.highScore);
    if (data.gamesPlayed !== undefined) localStorage.setItem('paperio_games', data.gamesPlayed);
    if (data.playerName !== undefined) localStorage.setItem('paperio_name', data.playerName);
    if (data.playerColor !== undefined) localStorage.setItem('paperio_player_color', data.playerColor);
    if (data.unlockedSkins !== undefined) localStorage.setItem('paperio_skins', JSON.stringify(data.unlockedSkins));
    if (data.selectedSkin !== undefined) localStorage.setItem('paperio_selected_skin', data.selectedSkin);
    if (data.settings !== undefined) localStorage.setItem('paperio_settings', JSON.stringify(data.settings));
}

// ==========================================
// AUTH & INITIALIZATION
// ==========================================
async function initializeAuth() {
    const loadingDetails = document.getElementById('loading-details');
    
    if (!auth) {
        loadingDetails.textContent = 'Firebase auth not available';
        return;
    }
    
    return new Promise((resolve) => {
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUser = user;
                firebaseReady = true;
                loadingDetails.textContent = 'Syncing data...';
                
                try {
                    const syncedData = await CloudSave.syncData();
                    applyLoadedData(syncedData);
                    document.getElementById('cloud-sync-detail').textContent = '✅ Logged in as ' + (user.email || 'Guest');
                    document.getElementById('login-google-btn').textContent = 'Signed in (' + user.email + ')';
                    document.getElementById('login-google-btn').disabled = true;
                } catch (error) {
                    console.error('Sync error', error);
                    applyLoadedData(getLocalSaveData());
                }
            } else {
                // Anonymous sign in by default so game works
                loadingDetails.textContent = 'Starting guest session...';
                try {
                    const result = await auth.signInAnonymously();
                    // Will trigger onAuthStateChanged again
                } catch (error) {
                    console.error('Anon auth error', error);
                    applyLoadedData(getLocalSaveData());
                    resolve();
                }
            }
            resolve();
        });
    });
}

// Google Login Handler
document.getElementById('login-google-btn').addEventListener('click', () => {
    if(!auth) return;
    const provider = new firebase.auth.GoogleAuthProvider();
    auth.signInWithPopup(provider).catch((error) => {
        alert("Login failed: " + error.message);
    });
});

function applyLoadedData(data) {
    if (!data) return;
    
    gamesPlayed = data.gamesPlayed || 0;
    highScore = data.highScore || 0;
    
    document.getElementById('games-played').textContent = gamesPlayed;
    document.getElementById('high-score').textContent = highScore + '%';
    
    if (data.playerName) {
        playerNameInput.value = data.playerName;
    }
    
    if (data.playerColor) {
        CONFIG.colors.player = data.playerColor;
        selectedPlayerColor = data.playerColor;
    }
    
    if (data.settings) {
        if (data.settings.botCount) CONFIG.botCount = data.settings.botCount;
        if (data.settings.speed) CONFIG.speed = data.settings.speed;
        if (data.settings.zoom) CONFIG.zoom = data.settings.zoom;
        if (data.settings.mapRadius) CONFIG.mapRadius = data.settings.mapRadius;
    }
    
    updateAccountTab();
}

// ==========================================
// GAME LOOP DATA GATHERING
// ==========================================
function getCurrentGameData() {
    return {
        highScore: highScore,
        gamesPlayed: gamesPlayed,
        playerName: playerNameInput.value.trim() || 'Guest',
        playerColor: CONFIG.colors.player,
        unlockedSkins: JSON.parse(localStorage.getItem('paperio_skins') || '["default"]'),
        selectedSkin: localStorage.getItem('paperio_selected_skin') || 'default',
        settings: {
            botCount: CONFIG.botCount,
            speed: CONFIG.speed,
            zoom: CONFIG.zoom,
            mapRadius: CONFIG.mapRadius,
            playerColor: CONFIG.colors.player,
            screenTheme: currentScreenTheme
        }
    };
}

// ==========================================
// AUTO SAVE (EVERY 15 SECONDS)
// ==========================================
let autoSaveInterval = null;

function startAutoSave() {
    if (autoSaveInterval) clearInterval(autoSaveInterval);
    
    // Save every 15 seconds silently
    autoSaveInterval = setInterval(async () => {
        if (gameRunning && !gamePaused && firebaseReady && currentUser) {
            // Save locally first
            const data = getCurrentGameData();
            saveLocalData(data);
            // Then cloud (silent = true)
            await CloudSave.save(data, true);
        }
    }, 15000);
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Manual Save (when closing settings or game over)
async function saveProgress(reason = 'manual') {
    const data = getCurrentGameData();
    saveLocalData(data);
    
    // For manual saves (game over, settings close), we do show status if settings open
    // but keep it silent if called during quick actions
    const silent = reason === 'auto';
    await CloudSave.save(data, silent);
}

// ==========================================
// ELEMENT REFERENCES & GAME LOGIC (UNCHANGED)
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('ui-overlay');
const startBtn = document.getElementById('start-btn');
const playerNameInput = document.getElementById('player-name');
const bgCanvas = document.getElementById('bg-animation');
const bgCtx = bgCanvas.getContext('2d');
const minimap = document.getElementById('minimap');
const minimapCtx = minimap.getContext('2d');
const scoreDisplay = document.getElementById('score-display');
const leaderboard = document.getElementById('leaderboard');
const leaderboardEntries = document.getElementById('leaderboard-entries');
const settingsBtn = document.getElementById('settings-btn');
const settingsPanel = document.getElementById('settings-panel');
const settingsOverlay = document.getElementById('settings-overlay');
const closeSettingsBtn = document.getElementById('close-settings');
const ingameSettingsBtn = document.getElementById('ingame-settings');
const pauseOverlay = document.getElementById('pause-overlay');
const resumeBtn = document.getElementById('resume-btn');
const quitBtn = document.getElementById('quit-btn');
const menuSkinsBtn = document.getElementById('menu-skins-btn');
const ingameSkinsBtn = document.getElementById('ingame-skins');
const loadingOverlay = document.getElementById('loading-overlay');

// GAME CONFIG
const CONFIG = {
    mapRadius: 2000,
    tileSize: 10,
    speed: 4,
    botSpeed: 3.5,
    turnSpeed: 0.08,
    playerSize: 20,
    minTrailDist: 5,
    zoom: 1.8,
    botCount: 10,
    colors: {
        player: '#ff4757',
        trail: '#ff6b81',
        bg: '#1a1a2e',
        mapBg: '#2d2d44',
        grid: 'rgba(255,255,255,0.05)',
        boundary: '#54a0ff'
    }
};

const BOT_COLORS = [
    '#2ed573', '#1e90ff', '#ffd32a', '#a55eea', 
    '#ff6348', '#26de81', '#fd79a8', '#00cec9',
    '#e17055', '#6c5ce7', '#fdcb6e', '#00b894'
];

const BOT_NAMES = [
    'Alex', 'Max', 'Sam', 'Jordan', 'Taylor', 
    'Casey', 'Riley', 'Quinn', 'Morgan', 'Avery',
    'Blake', 'Drew', 'Skyler', 'Charlie'
];

let gameRunning = false;
let gamePaused = false;
let mousePos = { x: 0, y: 0 };
let lastMousePos = { x: 0, y: 0 };
let mouseMoving = false;
let mouseStopTimer = null;
let lastInputMethod = 'mouse';
const keys = {};

let gridSize = 0;
let mapCenterX = 0;
let mapCenterY = 0;
let camera = { x: 0, y: 0 };

let player = null;
let bots = [];
let territory = [];
let cachedTotalTiles = 0;

let gamesPlayed = parseInt(localStorage.getItem('paperio_games') || '0');
let highScore = parseInt(localStorage.getItem('paperio_highscore') || '0');
document.getElementById('games-played').textContent = gamesPlayed;
document.getElementById('high-score').textContent = highScore + '%';
playerNameInput.value = localStorage.getItem('paperio_name') || '';

const savedSettings = JSON.parse(localStorage.getItem('paperio_settings') || '{}');
if (savedSettings.botCount) CONFIG.botCount = savedSettings.botCount;
if (savedSettings.speed) CONFIG.speed = savedSettings.speed;
if (savedSettings.zoom) CONFIG.zoom = savedSettings.zoom;
if (savedSettings.mapRadius) CONFIG.mapRadius = savedSettings.mapRadius;
if (savedSettings.playerColor) CONFIG.colors.player = savedSettings.playerColor;

let currentScreenTheme = localStorage.getItem('paperio_screen_theme') || 'original';
applyScreenTheme(currentScreenTheme);

let minimapNeedsUpdate = true;

function applyScreenTheme(themeName) {
    currentScreenTheme = themeName;
    if (themeName === 'original') {
        overlay.classList.add('theme-original');
    } else {
        overlay.classList.remove('theme-original');
    }
}

// SETTINGS PANEL LOGIC
let currentTab = 'game';
let selectedPlayerColor = CONFIG.colors.player;

function initSettingsPanel() {
    const botSlider = document.getElementById('setting-bots');
    const speedSlider = document.getElementById('setting-speed');
    const zoomSlider = document.getElementById('setting-zoom');
    const mapSizeSelect = document.getElementById('setting-mapsize');
    const colorPicker = document.getElementById('setting-color');

    botSlider.value = CONFIG.botCount;
    document.getElementById('bots-value').textContent = CONFIG.botCount;
    speedSlider.value = Math.round(CONFIG.speed);
    document.getElementById('speed-value').textContent = Math.round(CONFIG.speed);
    zoomSlider.value = Math.round(CONFIG.zoom * 10);
    document.getElementById('zoom-value').textContent = CONFIG.zoom.toFixed(1) + 'x';
    mapSizeSelect.value = CONFIG.mapRadius;
    colorPicker.value = CONFIG.colors.player;
    selectedPlayerColor = CONFIG.colors.player;

    updateAccountTab();

    botSlider.addEventListener('input', (e) => {
        document.getElementById('bots-value').textContent = e.target.value;
    });

    speedSlider.addEventListener('input', (e) => {
        document.getElementById('speed-value').textContent = e.target.value;
    });

    zoomSlider.addEventListener('input', (e) => {
        document.getElementById('zoom-value').textContent = (e.target.value / 10).toFixed(1) + 'x';
    });

    colorPicker.addEventListener('input', (e) => {
        selectedPlayerColor = e.target.value;
        updateColorSelection(e.target.value);
    });

    document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            switchTab(tabName);
        });
    });

    document.querySelectorAll('.theme-color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const color = btn.dataset.color;
            selectedPlayerColor = color;
            colorPicker.value = color;
            updateColorSelection(color);
        });
    });

    document.querySelectorAll('.screen-theme-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const theme = btn.dataset.screenTheme;
            document.querySelectorAll('.screen-theme-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            applyScreenTheme(theme);
        });
    });

    document.getElementById('reset-stats-btn').addEventListener('click', async () => {
        if (confirm('Are you sure you want to reset all your stats?')) {
            localStorage.removeItem('paperio_games');
            localStorage.removeItem('paperio_highscore');
            gamesPlayed = 0;
            highScore = 0;
            document.getElementById('games-played').textContent = '0';
            document.getElementById('high-score').textContent = '0%';
            updateAccountTab();
            await saveProgress('reset_stats');
        }
    });

    updateColorSelection(CONFIG.colors.player);
    document.querySelectorAll('.screen-theme-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.screenTheme === currentScreenTheme);
    });
}

function switchTab(tabName) {
    currentTab = tabName;
    document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === 'tab-' + tabName);
    });
}

function updateColorSelection(color) {
    document.querySelectorAll('.theme-color-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.color === color);
    });
}

function updateAccountTab() {
    const name = playerNameInput.value.trim() || 'Guest Player';
    document.getElementById('account-name').textContent = name;
    document.getElementById('account-avatar').textContent = name.charAt(0).toUpperCase();
    document.getElementById('account-games').textContent = gamesPlayed;
    document.getElementById('account-best').textContent = highScore + '%';
    
    // Status text update handled by sync functions
}

function openSettings() {
    settingsPanel.style.display = 'block';
    settingsOverlay.style.display = 'block';
    updateAccountTab();
    switchTab('game');
    document.querySelectorAll('.screen-theme-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.screenTheme === currentScreenTheme);
    });
}

async function closeSettings() {
    CONFIG.botCount = parseInt(document.getElementById('setting-bots').value);
    CONFIG.speed = parseInt(document.getElementById('setting-speed').value);
    CONFIG.botSpeed = CONFIG.speed * 0.875;
    CONFIG.zoom = parseInt(document.getElementById('setting-zoom').value) / 10;
    CONFIG.mapRadius = parseInt(document.getElementById('setting-mapsize').value);
    CONFIG.colors.player = selectedPlayerColor;

    localStorage.setItem('paperio_settings', JSON.stringify({
        botCount: CONFIG.botCount,
        speed: CONFIG.speed,
        zoom: CONFIG.zoom,
        mapRadius: CONFIG.mapRadius,
        playerColor: CONFIG.colors.player
    }));
    localStorage.setItem('paperio_screen_theme', currentScreenTheme);

    settingsPanel.style.display = 'none';
    settingsOverlay.style.display = 'none';
    
    await saveProgress('settings_saved');
}

settingsBtn.onclick = openSettings;
settingsOverlay.onclick = closeSettings;
closeSettingsBtn.onclick = closeSettings;

ingameSettingsBtn.onclick = () => {
    gamePaused = true;
    pauseOverlay.style.display = 'flex';
};

resumeBtn.onclick = () => {
    gamePaused = false;
    pauseOverlay.style.display = 'none';
};

quitBtn.onclick = async () => {
    gamePaused = false;
    gameRunning = false;
    stopAutoSave();
    
    pauseOverlay.style.display = 'none';
    scoreDisplay.style.display = 'none';
    leaderboard.style.display = 'none';
    ingameSettingsBtn.style.display = 'none';
    ingameSkinsBtn.style.display = 'none';
    overlay.style.display = 'flex';
    animateMenuBackground();
    
    await saveProgress('quit_game');
};

function openSkinsPanel() {
    alert('Skins panel coming soon! 🎨\nYour unlocked skins will be saved to the cloud.');
}

menuSkinsBtn.onclick = openSkinsPanel;
ingameSkinsBtn.onclick = openSkinsPanel;

initSettingsPanel();

// MENU BACKGROUND ANIMATION
let menuBlocks = [];

function initMenuBackground() {
    bgCanvas.width = window.innerWidth;
    bgCanvas.height = window.innerHeight;
    menuBlocks = [];
    for (let i = 0; i < 25; i++) {
        menuBlocks.push({
            x: Math.random() * bgCanvas.width,
            y: Math.random() * bgCanvas.height,
            size: 30 + Math.random() * 60,
            color: BOT_COLORS[Math.floor(Math.random() * BOT_COLORS.length)],
            speedX: (Math.random() - 0.5) * 2,
            speedY: (Math.random() - 0.5) * 2,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.02
        });
    }
}

function animateMenuBackground() {
    if (gameRunning) return;
    bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
    for (let block of menuBlocks) {
        block.x += block.speedX;
        block.y += block.speedY;
        block.rotation += block.rotationSpeed;
        if (block.x < -block.size) block.x = bgCanvas.width + block.size;
        if (block.x > bgCanvas.width + block.size) block.x = -block.size;
        if (block.y < -block.size) block.y = bgCanvas.height + block.size;
        if (block.y > bgCanvas.height + block.size) block.y = -block.size;
        bgCtx.save();
        bgCtx.translate(block.x, block.y);
        bgCtx.rotate(block.rotation);
        bgCtx.fillStyle = block.color;
        bgCtx.fillRect(-block.size/2, -block.size/2, block.size, block.size);
        bgCtx.restore();
    }
    requestAnimationFrame(animateMenuBackground);
}

// GAME ENTITIES AND LOGIC (GAMEPLAY CODE)
function initGridData() {
    gridSize = Math.ceil((CONFIG.mapRadius * 2) / CONFIG.tileSize);
    mapCenterX = CONFIG.mapRadius;
    mapCenterY = CONFIG.mapRadius;
    territory = [];
    for (let x = 0; x < gridSize; x++) {
        territory[x] = new Uint8Array(gridSize);
    }
    
    cachedTotalTiles = 0;
    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            const worldX = x * CONFIG.tileSize + CONFIG.tileSize / 2;
            const worldY = y * CONFIG.tileSize + CONFIG.tileSize / 2;
            if (isInsideMap(worldX, worldY)) {
                cachedTotalTiles++;
            }
        }
    }
}

function isInsideMap(worldX, worldY) {
    const dx = worldX - mapCenterX;
    const dy = worldY - mapCenterY;
    return Math.sqrt(dx * dx + dy * dy) <= CONFIG.mapRadius;
}

function worldToGrid(worldX, worldY) {
    return {
        gx: Math.floor(worldX / CONFIG.tileSize),
        gy: Math.floor(worldY / CONFIG.tileSize)
    };
}

function setTerritory(gx, gy, val) {
    if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize && territory[gx]) {
        territory[gx][gy] = val;
    }
}

function getTerritory(gx, gy) {
    if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize && territory[gx]) {
        return territory[gx][gy];
    }
    return 0;
}

function isPositionInAnyTerritory(worldX, worldY, checkRadius) {
    const { gx, gy } = worldToGrid(worldX, worldY);
    const gridRadius = Math.ceil(checkRadius / CONFIG.tileSize);
    
    for (let dx = -gridRadius; dx <= gridRadius; dx++) {
        for (let dy = -gridRadius; dy <= gridRadius; dy++) {
            if (getTerritory(gx + dx, gy + dy) > 0) {
                return true;
            }
        }
    }
    return false;
}

class Entity {
    constructor(id, color, name) {
        this.id = id;
        this.color = color;
        this.trailColor = this.lightenColor(color, 30);
        this.name = name;
        this.x = 0;
        this.y = 0;
        this.angle = 0;
        this.trail = [];
        this.isOutside = false;
        this.lastSafePos = { x: 0, y: 0 };
        this.alive = true;
        this.territoryId = id + 1;
        this.cachedScore = 0;
        this.scoreUpdateTimer = 0;
    }

    lightenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    spawn(avoidX, avoidY, avoidDist) {
        let attempts = 0;
        const startZoneRadius = 80;
        
        do {
            const angle = Math.random() * Math.PI * 2;
            const dist = 300 + Math.random() * (CONFIG.mapRadius - 500);
            this.x = mapCenterX + Math.cos(angle) * dist;
            this.y = mapCenterY + Math.sin(angle) * dist;
            attempts++;
            
            const tooCloseToAvoid = avoidX && Math.hypot(this.x - avoidX, this.y - avoidY) < avoidDist;
            const overlapsTerritory = isPositionInAnyTerritory(this.x, this.y, startZoneRadius);
            const tooCloseToEdge = Math.hypot(this.x - mapCenterX, this.y - mapCenterY) > CONFIG.mapRadius - 150;
            
            if (!tooCloseToAvoid && !overlapsTerritory && !tooCloseToEdge) {
                break;
            }
        } while (attempts < 100);

        this.angle = Math.random() * Math.PI * 2;
        this.trail = [];
        this.isOutside = false;
        this.lastSafePos = { x: this.x, y: this.y };
        this.alive = true;
        this.createStartZone();
    }

    createStartZone() {
        const r = 6;
        const { gx: startGX, gy: startGY } = worldToGrid(this.x, this.y);
        for (let x = -r; x <= r; x++) {
            for (let y = -r; y <= r; y++) {
                if (Math.sqrt(x*x + y*y) <= r) {
                    setTerritory(startGX + x, startGY + y, this.territoryId);
                }
            }
        }
        minimapNeedsUpdate = true;
    }

    handleBoundary() {
        const dx = this.x - mapCenterX;
        const dy = this.y - mapCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const edgeBuffer = 50;

        if (dist > CONFIG.mapRadius - edgeBuffer) {
            const bufferProgress = (dist - (CONFIG.mapRadius - edgeBuffer)) / edgeBuffer;
            const pushStrength = Math.min(bufferProgress * 2, 1) * CONFIG.speed * 0.5;
            this.x -= (dx / dist) * pushStrength;
            this.y -= (dy / dist) * pushStrength;

            const wallAngle = Math.atan2(dy, dx);
            let angleToWall = this.angle - wallAngle;
            while (angleToWall < -Math.PI) angleToWall += Math.PI * 2;
            while (angleToWall > Math.PI) angleToWall -= Math.PI * 2;

            if (Math.abs(angleToWall) < Math.PI / 2) {
                const turnStrength = bufferProgress * CONFIG.turnSpeed * 1.5;
                this.angle += angleToWall > 0 ? -turnStrength : turnStrength;
            }
        }

        if (dist > CONFIG.mapRadius - 5) {
            const clampDist = CONFIG.mapRadius - 5;
            this.x = mapCenterX + (dx / dist) * clampDist;
            this.y = mapCenterY + (dy / dist) * clampDist;
        }
    }

    checkTrailCollision(otherTrail, otherIsOutside) {
        if (!otherIsOutside || otherTrail.length < 5) return false;
        for (let i = 0; i < otherTrail.length - 3; i++) {
            const t = otherTrail[i];
            if (Math.hypot(this.x - t.x, this.y - t.y) < CONFIG.playerSize * 0.8) {
                return true;
            }
        }
        return false;
    }

    markThickLineOnGrid(x1, y1, x2, y2, thickness) {
        const dist = Math.hypot(x2 - x1, y2 - y1);
        const steps = Math.max(1, Math.ceil(dist / 2));
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = x1 + (x2 - x1) * t;
            const y = y1 + (y2 - y1) * t;
            const { gx, gy } = worldToGrid(x, y);
            for (let dx = -thickness; dx <= thickness; dx++) {
                for (let dy = -thickness; dy <= thickness; dy++) {
                    setTerritory(gx + dx, gy + dy, this.territoryId);
                }
            }
        }
    }

    capture() {
        if (this.trail.length < 3) return;

        for (let i = 0; i < this.trail.length - 1; i++) {
            this.markThickLineOnGrid(
                this.trail[i].x, this.trail[i].y,
                this.trail[i + 1].x, this.trail[i + 1].y,
                2
            );
        }

        this.floodFillCapture();
        minimapNeedsUpdate = true;
        this.scoreUpdateTimer = 0;
    }

    floodFillCapture() {
        const visited = new Uint8Array(gridSize * gridSize);
        const stack = [];

        for (let x = 0; x < gridSize; x++) {
            const terr1 = getTerritory(x, 0);
            if (terr1 !== this.territoryId) {
                const idx = x;
                if (!visited[idx]) { visited[idx] = 1; stack.push(idx); }
            }
            const terr2 = getTerritory(x, gridSize - 1);
            if (terr2 !== this.territoryId) {
                const idx = (gridSize - 1) * gridSize + x;
                if (!visited[idx]) { visited[idx] = 1; stack.push(idx); }
            }
        }
        for (let y = 0; y < gridSize; y++) {
            const terr1 = getTerritory(0, y);
            if (terr1 !== this.territoryId) {
                const idx = y * gridSize;
                if (!visited[idx]) { visited[idx] = 1; stack.push(idx); }
            }
            const terr2 = getTerritory(gridSize - 1, y);
            if (terr2 !== this.territoryId) {
                const idx = y * gridSize + (gridSize - 1);
                if (!visited[idx]) { visited[idx] = 1; stack.push(idx); }
            }
        }

        while (stack.length > 0) {
            const idx = stack.pop();
            const x = idx % gridSize;
            const y = Math.floor(idx / gridSize);

            const neighbors = [
                { x: x + 1, y: y }, { x: x - 1, y: y },
                { x: x, y: y + 1 }, { x: x, y: y - 1 }
            ];

            for (let n of neighbors) {
                if (n.x >= 0 && n.x < gridSize && n.y >= 0 && n.y < gridSize) {
                    const nIdx = n.y * gridSize + n.x;
                    if (visited[nIdx] === 0) {
                        const terr = getTerritory(n.x, n.y);
                        if (terr !== this.territoryId) {
                            visited[nIdx] = 1;
                            stack.push(nIdx);
                        }
                    }
                }
            }
        }

        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                const idx = y * gridSize + x;
                if (visited[idx] === 0) {
                    const terr = getTerritory(x, y);
                    if (terr !== this.territoryId) {
                        setTerritory(x, y, this.territoryId);
                    }
                }
            }
        }
    }

    calculateScore() {
        this.scoreUpdateTimer--;
        if (this.scoreUpdateTimer > 0) {
            return this.cachedScore;
        }
        this.scoreUpdateTimer = 30;
        
        let count = 0;
        const step = 2;
        let sampledTotal = 0;
        
        for (let x = 0; x < gridSize; x += step) {
            for (let y = 0; y < gridSize; y += step) {
                const worldX = x * CONFIG.tileSize + CONFIG.tileSize / 2;
                const worldY = y * CONFIG.tileSize + CONFIG.tileSize / 2;
                if (isInsideMap(worldX, worldY)) {
                    sampledTotal++;
                    if (getTerritory(x, y) === this.territoryId) count++;
                }
            }
        }
        
        this.cachedScore = sampledTotal > 0 ? Math.round((count / sampledTotal) * 100 * 10) / 10 : 0;
        return this.cachedScore;
    }

    drawTerritory(camX, camY) {
        if (!this.alive) return;

        const tileScreenSize = CONFIG.tileSize * CONFIG.zoom;
        const minGX = Math.max(0, Math.floor(camX / CONFIG.tileSize) - 2);
        const maxGX = Math.min(gridSize - 1, Math.ceil((camX + canvas.width / CONFIG.zoom) / CONFIG.tileSize) + 2);
        const minGY = Math.max(0, Math.floor(camY / CONFIG.tileSize) - 2);
        const maxGY = Math.min(gridSize - 1, Math.ceil((camY + canvas.height / CONFIG.zoom) / CONFIG.tileSize) + 2);

        ctx.fillStyle = this.color;
        for (let x = minGX; x <= maxGX; x++) {
            for (let y = minGY; y <= maxGY; y++) {
                if (getTerritory(x, y) === this.territoryId) {
                    const screenX = (x * CONFIG.tileSize - camX) * CONFIG.zoom;
                    const screenY = (y * CONFIG.tileSize - camY) * CONFIG.zoom;
                    ctx.fillRect(screenX, screenY, tileScreenSize + 1, tileScreenSize + 1);
                }
            }
        }
    }

    drawEntity(camX, camY) {
        if (!this.alive) return;

        if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = CONFIG.playerSize * CONFIG.zoom;
            ctx.strokeStyle = this.trailColor;

            const startX = (this.trail[0].x - camX) * CONFIG.zoom;
            const startY = (this.trail[0].y - camY) * CONFIG.zoom;
            ctx.moveTo(startX, startY);

            for (let i = 1; i < this.trail.length; i++) {
                ctx.lineTo((this.trail[i].x - camX) * CONFIG.zoom, (this.trail[i].y - camY) * CONFIG.zoom);
            }
            ctx.lineTo((this.x - camX) * CONFIG.zoom, (this.y - camY) * CONFIG.zoom);
            ctx.stroke();
        }

        const screenX = (this.x - camX) * CONFIG.zoom;
        const screenY = (this.y - camY) * CONFIG.zoom;

        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 10;
        const s = CONFIG.playerSize * CONFIG.zoom;
        ctx.fillRect(-s / 2, -s / 2, s, s);
        ctx.restore();

        ctx.fillStyle = 'white';
        ctx.font = `bold ${14 * CONFIG.zoom}px 'Nunito', Arial`;
        ctx.textAlign = 'center';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 3;
        ctx.fillText(this.name, screenX, screenY - 25 * CONFIG.zoom);
        ctx.shadowBlur = 0;
    }
}

class Player extends Entity {
    constructor() {
        super(0, CONFIG.colors.player, 'Player');
    }

    reset(name) {
        this.name = name;
        this.color = CONFIG.colors.player;
        this.trailColor = this.lightenColor(this.color, 30);
        this.x = mapCenterX;
        this.y = mapCenterY;
        this.angle = -Math.PI / 2;
        this.trail = [];
        this.isOutside = false;
        this.lastSafePos = { x: this.x, y: this.y };
        this.alive = true;
        this.createStartZone();
    }

    update() {
        if (!gameRunning || !this.alive || gamePaused) return;

        if (lastInputMethod === 'keyboard') {
            if (keys['a'] || keys['arrowleft']) this.angle -= CONFIG.turnSpeed;
            if (keys['d'] || keys['arrowright']) this.angle += CONFIG.turnSpeed;
        } else if (mouseMoving) {
            const worldMouseX = mousePos.x / CONFIG.zoom + camera.x;
            const worldMouseY = mousePos.y / CONFIG.zoom + camera.y;
            const dx = worldMouseX - this.x;
            const dy = worldMouseY - this.y;
            const targetAngle = Math.atan2(dy, dx);
            let angleDiff = targetAngle - this.angle;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            this.angle += angleDiff * 0.15;
        }

        this.x += Math.cos(this.angle) * CONFIG.speed;
        this.y += Math.sin(this.angle) * CONFIG.speed;
        this.handleBoundary();

        for (let bot of bots) {
            if (bot.alive && bot.isOutside && bot.trail.length > 5) {
                for (let i = 0; i < bot.trail.length - 3; i++) {
                    const t = bot.trail[i];
                    if (Math.hypot(this.x - t.x, this.y - t.y) < CONFIG.playerSize * 0.8) {
                        bot.respawn();
                        break;
                    }
                }
            }
        }

        const { gx, gy } = worldToGrid(this.x, this.y);
        const onTerritory = getTerritory(gx, gy) === this.territoryId;

        if (!onTerritory) {
            if (!this.isOutside) {
                this.trail = [{ x: this.lastSafePos.x, y: this.lastSafePos.y }];
            }
            this.isOutside = true;

            const lastP = this.trail[this.trail.length - 1];
            if (!lastP || Math.hypot(this.x - lastP.x, this.y - lastP.y) > CONFIG.minTrailDist) {
                this.trail.push({ x: this.x, y: this.y });
            }

            if (this.trail.length > 20) {
                for (let i = 0; i < this.trail.length - 15; i++) {
                    if (Math.hypot(this.x - this.trail[i].x, this.y - this.trail[i].y) < CONFIG.playerSize / 2) {
                        this.die();
                        return;
                    }
                }
            }
        } else {
            this.lastSafePos = { x: this.x, y: this.y };
            if (this.isOutside && this.trail.length > 2) {
                this.trail.push({ x: this.x, y: this.y });
                this.capture();
                this.isOutside = false;
                this.trail = [];
            }
        }

        camera.x = this.x - (canvas.width / 2) / CONFIG.zoom;
        camera.y = this.y - (canvas.height / 2) / CONFIG.zoom;
    }

    async die() {
        this.alive = false;
        gameRunning = false;
        stopAutoSave();

        const score = this.calculateScore();
        if (score > highScore) {
            highScore = Math.round(score);
            localStorage.setItem('paperio_highscore', highScore);
            document.getElementById('high-score').textContent = highScore + '%';
        }

        scoreDisplay.style.display = 'none';
        leaderboard.style.display = 'none';
        ingameSettingsBtn.style.display = 'none';
        ingameSkinsBtn.style.display = 'none';
        overlay.style.display = 'flex';
        animateMenuBackground();
        
        await saveProgress('game_over');
    }
}

class Bot extends Entity {
    constructor(id, color, name) {
        super(id, color, name);
        this.targetAngle = 0;
        this.turnTimer = 0;
        this.state = 'patrolling';
        this.stateTimer = 0;
        this.curveDirection = 1;
        this.curveStrength = 0;
        this.territoryCenter = { x: 0, y: 0 };
        this.expansionAngle = 0;
        this.maxTrailLength = 0;
        this.returnTarget = null;
    }

    reset() {
        this.spawn(player ? player.x : mapCenterX, player ? player.y : mapCenterY, 500);
        this.turnTimer = Math.random() * 50;
        this.state = 'patrolling';
        this.stateTimer = 60 + Math.random() * 120;
        this.curveDirection = Math.random() > 0.5 ? 1 : -1;
        this.curveStrength = 0.02 + Math.random() * 0.03;
        this.territoryCenter = { x: this.x, y: this.y };
        this.maxTrailLength = 40 + Math.random() * 60;
        this.returnTarget = null;
    }

    findNearestTerritoryPoint() {
        const { gx, gy } = worldToGrid(this.x, this.y);
        let nearestDist = Infinity;
        let nearestPoint = null;
        
        for (let radius = 1; radius < 150; radius += 2) {
            let found = false;
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
                    const checkX = gx + dx;
                    const checkY = gy + dy;
                    if (getTerritory(checkX, checkY) === this.territoryId) {
                        const dist = Math.hypot(dx, dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPoint = { 
                                x: checkX * CONFIG.tileSize + CONFIG.tileSize / 2, 
                                y: checkY * CONFIG.tileSize + CONFIG.tileSize / 2 
                            };
                            found = true;
                        }
                    }
                }
            }
            if (found) break;
        }
        return nearestPoint;
    }

    updateTerritoryCenter() {
        let sumX = 0, sumY = 0, count = 0;
        const { gx, gy } = worldToGrid(this.x, this.y);
        const searchRadius = 40;
        
        for (let dx = -searchRadius; dx <= searchRadius; dx += 3) {
            for (let dy = -searchRadius; dy <= searchRadius; dy += 3) {
                if (getTerritory(gx + dx, gy + dy) === this.territoryId) {
                    sumX += (gx + dx) * CONFIG.tileSize;
                    sumY += (gy + dy) * CONFIG.tileSize;
                    count++;
                }
            }
        }
        
        if (count > 0) {
            this.territoryCenter = { x: sumX / count, y: sumY / count };
        }
    }

    avoidDanger() {
        if (player && player.alive && player.isOutside && player.trail.length > 3) {
            for (let t of player.trail) {
                const dist = Math.hypot(this.x - t.x, this.y - t.y);
                if (dist < 100) {
                    const awayAngle = Math.atan2(this.y - t.y, this.x - t.x);
                    this.targetAngle = awayAngle;
                    return true;
                }
            }
        }
        
        for (let other of bots) {
            if (other !== this && other.alive && other.isOutside && other.trail.length > 3) {
                for (let t of other.trail) {
                    const dist = Math.hypot(this.x - t.x, this.y - t.y);
                    if (dist < 80) {
                        const awayAngle = Math.atan2(this.y - t.y, this.x - t.x);
                        this.targetAngle = awayAngle;
                        return true;
                    }
                }
            }
        }
        
        if (player && player.alive) {
            const distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
            if (distToPlayer < 150 && this.isOutside) {
                const awayAngle = Math.atan2(this.y - player.y, this.x - player.x);
                this.targetAngle = awayAngle;
                return true;
            }
        }
        
        return false;
    }

    update() {
        if (!this.alive || gamePaused) return;

        this.stateTimer--;
        this.turnTimer--;

        const { gx, gy } = worldToGrid(this.x, this.y);
        const onTerritory = getTerritory(gx, gy) === this.territoryId;

        if (this.state === 'patrolling') {
            if (this.turnTimer <= 0) {
                this.curveDirection = Math.random() > 0.5 ? 1 : -1;
                this.curveStrength = 0.015 + Math.random() * 0.025;
                this.turnTimer = 30 + Math.random() * 50;
            }
            
            this.angle += this.curveDirection * this.curveStrength;
            
            const lookAheadDist = 80;
            const lookAheadX = this.x + Math.cos(this.angle) * lookAheadDist;
            const lookAheadY = this.y + Math.sin(this.angle) * lookAheadDist;
            const { gx: laGx, gy: laGy } = worldToGrid(lookAheadX, lookAheadY);
            
            if (getTerritory(laGx, laGy) !== this.territoryId) {
                this.updateTerritoryCenter();
                this.targetAngle = Math.atan2(this.territoryCenter.y - this.y, this.territoryCenter.x - this.x);
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                this.angle += angleDiff * 0.12;
            }
            
            if (this.stateTimer <= 0) {
                this.state = 'expanding';
                this.expansionAngle = this.angle + (Math.random() - 0.5) * 0.8;
                this.curveDirection = Math.random() > 0.5 ? 1 : -1;
                this.curveStrength = 0.02 + Math.random() * 0.03;
                this.maxTrailLength = 35 + Math.random() * 50;
                this.stateTimer = 400;
            }
        } 
        else if (this.state === 'expanding') {
            if (!this.avoidDanger()) {
                if (this.trail.length < 10) {
                    let angleDiff = this.expansionAngle - this.angle;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    this.angle += angleDiff * 0.08;
                }
                
                this.angle += this.curveDirection * this.curveStrength;
                
                if (this.turnTimer <= 0) {
                    this.curveStrength = 0.015 + Math.random() * 0.035;
                    this.turnTimer = 20 + Math.random() * 30;
                }
            } else {
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                this.angle += angleDiff * 0.1;
            }
            
            const shouldReturn = this.trail.length > this.maxTrailLength || 
                                 this.stateTimer <= 0 || 
                                 this.stateTimer <= 200 && this.trail.length > 20;
            
            if (shouldReturn && this.isOutside) {
                this.state = 'returning';
                this.stateTimer = 600;
                this.returnTarget = this.findNearestTerritoryPoint();
                this.curveDirection *= -1;
            }
        } 
        else if (this.state === 'returning') {
            const inDanger = this.avoidDanger();
            
            if (!inDanger) {
                if (this.turnTimer <= 0 || !this.returnTarget) {
                    this.returnTarget = this.findNearestTerritoryPoint();
                    this.turnTimer = 15;
                }
                
                if (this.returnTarget) {
                    this.targetAngle = Math.atan2(
                        this.returnTarget.y - this.y, 
                        this.returnTarget.x - this.x
                    );
                    
                    this.targetAngle += this.curveDirection * 0.15;
                    
                    let angleDiff = this.targetAngle - this.angle;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    this.angle += angleDiff * 0.15;
                } else {
                    this.targetAngle = Math.atan2(
                        this.territoryCenter.y - this.y, 
                        this.territoryCenter.x - this.x
                    );
                    let angleDiff = this.targetAngle - this.angle;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    this.angle += angleDiff * 0.12;
                }
            } else {
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                this.angle += angleDiff * 0.12;
            }
            
            if (this.stateTimer <= 0 && this.isOutside) {
                this.respawn();
                return;
            }
        }

        this.x += Math.cos(this.angle) * CONFIG.botSpeed;
        this.y += Math.sin(this.angle) * CONFIG.botSpeed;
        this.handleBoundary();

        if (player && player.alive && player.isOutside && player.trail.length > 5) {
            for (let i = 0; i < player.trail.length - 3; i++) {
                const t = player.trail[i];
                if (Math.hypot(this.x - t.x, this.y - t.y) < CONFIG.playerSize * 0.8) {
                    player.die();
                    return;
                }
            }
        }

        for (let other of bots) {
            if (other !== this && other.alive && this.checkTrailCollision(other.trail, other.isOutside)) {
                this.respawn();
                return;
            }
        }

        if (!onTerritory) {
            if (!this.isOutside) {
                this.trail = [{ x: this.lastSafePos.x, y: this.lastSafePos.y }];
            }
            this.isOutside = true;

            const lastP = this.trail[this.trail.length - 1];
            if (!lastP || Math.hypot(this.x - lastP.x, this.y - lastP.y) > CONFIG.minTrailDist) {
                this.trail.push({ x: this.x, y: this.y });
            }

            if (this.trail.length > 20) {
                for (let i = 0; i < this.trail.length - 15; i++) {
                    if (Math.hypot(this.x - this.trail[i].x, this.y - this.trail[i].y) < CONFIG.playerSize / 2) {
                        this.respawn();
                        return;
                    }
                }
            }
        } else {
            this.lastSafePos = { x: this.x, y: this.y };
            if (this.isOutside && this.trail.length > 2) {
                this.trail.push({ x: this.x, y: this.y });
                this.capture();
                this.isOutside = false;
                this.trail = [];
                this.state = 'patrolling';
                this.stateTimer = 60 + Math.random() * 100;
                this.updateTerritoryCenter();
                this.returnTarget = null;
            }
        }
    }

    respawn() {
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                if (getTerritory(x, y) === this.territoryId) {
                    setTerritory(x, y, 0);
                }
            }
        }
        this.reset();
        minimapNeedsUpdate = true;
    }
}

function createBots() {
    bots = [];
    for (let i = 0; i < CONFIG.botCount; i++) {
        const color = BOT_COLORS[i % BOT_COLORS.length];
        const name = BOT_NAMES[i % BOT_NAMES.length];
        const bot = new Bot(i + 1, color, name);
        bot.reset();
        bots.push(bot);
    }
}

function drawMap() {
    const centerScreenX = (mapCenterX - camera.x) * CONFIG.zoom;
    const centerScreenY = (mapCenterY - camera.y) * CONFIG.zoom;
    const radiusScreen = CONFIG.mapRadius * CONFIG.zoom;

    ctx.beginPath();
    ctx.arc(centerScreenX, centerScreenY, radiusScreen, 0, Math.PI * 2);
    ctx.fillStyle = CONFIG.colors.mapBg;
    ctx.fill();

    ctx.save();
    ctx.beginPath();
    ctx.arc(centerScreenX, centerScreenY, radiusScreen, 0, Math.PI * 2);
    ctx.clip();

    ctx.strokeStyle = CONFIG.colors.grid;
    ctx.lineWidth = 1;
    const gridSpacing = 50 * CONFIG.zoom;
    ctx.beginPath();
    for (let x = -radiusScreen; x <= radiusScreen; x += gridSpacing) {
        const screenX = centerScreenX + x;
        ctx.moveTo(screenX, centerScreenY - radiusScreen);
        ctx.lineTo(screenX, centerScreenY + radiusScreen);
    }
    for (let y = -radiusScreen; y <= radiusScreen; y += gridSpacing) {
        const screenY = centerScreenY + y;
        ctx.moveTo(centerScreenX - radiusScreen, screenY);
        ctx.lineTo(centerScreenX + radiusScreen, screenY);
    }
    ctx.stroke();
    ctx.restore();

    ctx.beginPath();
    ctx.arc(centerScreenX, centerScreenY, radiusScreen, 0, Math.PI * 2);
    ctx.strokeStyle = CONFIG.colors.boundary;
    ctx.lineWidth = 4 * CONFIG.zoom;
    ctx.stroke();
}

function drawMinimap() {
    const size = 150;
    const scale = size / (CONFIG.mapRadius * 2);

    minimapCtx.clearRect(0, 0, size, size);

    minimapCtx.beginPath();
    minimapCtx.arc(size / 2, size / 2, size / 2 - 2, 0, Math.PI * 2);
    minimapCtx.fillStyle = CONFIG.colors.mapBg;
    minimapCtx.fill();

    minimapCtx.save();
    minimapCtx.beginPath();
    minimapCtx.arc(size / 2, size / 2, size / 2 - 2, 0, Math.PI * 2);
    minimapCtx.clip();

    const step = Math.max(1, Math.floor(gridSize / 100));
    for (let x = 0; x < gridSize; x += step) {
        for (let y = 0; y < gridSize; y += step) {
            const terr = getTerritory(x, y);
            if (terr > 0) {
                if (terr === 1) {
                    minimapCtx.fillStyle = CONFIG.colors.player;
                } else {
                    const botIdx = terr - 2;
                    if (bots[botIdx]) {
                        minimapCtx.fillStyle = bots[botIdx].color;
                    }
                }
                const miniX = x * CONFIG.tileSize * scale;
                const miniY = y * CONFIG.tileSize * scale;
                const miniSize = Math.max(2, CONFIG.tileSize * scale * step);
                minimapCtx.fillRect(miniX, miniY, miniSize, miniSize);
            }
        }
    }

    for (let bot of bots) {
        if (bot.alive) {
            minimapCtx.fillStyle = bot.color;
            minimapCtx.beginPath();
            minimapCtx.arc(bot.x * scale, bot.y * scale, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }
    }

    if (player && player.alive) {
        minimapCtx.fillStyle = 'white';
        minimapCtx.beginPath();
        minimapCtx.arc(player.x * scale, player.y * scale, 5, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.fillStyle = CONFIG.colors.player;
        minimapCtx.beginPath();
        minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
        minimapCtx.fill();
    }

    minimapCtx.restore();

    minimapCtx.beginPath();
    minimapCtx.arc(size / 2, size / 2, size / 2 - 2, 0, Math.PI * 2);
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    minimapCtx.lineWidth = 2;
    minimapCtx.stroke();
}

function updateLeaderboard() {
    const scores = [];

    if (player && player.alive) {
        scores.push({ name: player.name, color: player.color, score: player.calculateScore() });
    }

    for (let bot of bots) {
        if (bot.alive) {
            scores.push({ name: bot.name, color: bot.color, score: bot.calculateScore() });
        }
    }

    scores.sort((a, b) => b.score - a.score);
    const top5 = scores.slice(0, 5);

    leaderboardEntries.innerHTML = '';
    for (let entry of top5) {
        const div = document.createElement('div');
        div.className = 'leaderboard-entry';
        div.innerHTML = `
            <div class="leaderboard-color" style="background: ${entry.color}"></div>
            <span class="leaderboard-name">${entry.name}</span>
            <span class="leaderboard-score">${entry.score.toFixed(1)}%</span>
        `;
        leaderboardEntries.appendChild(div);
    }

    if (player && player.alive) {
        scoreDisplay.textContent = player.calculateScore().toFixed(1) + '%';
    }
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameRunning && !gamePaused) {
        player.update();
        for (let bot of bots) {
            bot.update();
        }
    }

    if (gameRunning) {
        drawMap();
        
        player.drawTerritory(camera.x, camera.y);
        for (let bot of bots) {
            bot.drawTerritory(camera.x, camera.y);
        }
        
        for (let bot of bots) {
            bot.drawEntity(camera.x, camera.y);
        }
        player.drawEntity(camera.x, camera.y);

        drawMinimap();
        updateLeaderboard();
    }

    requestAnimationFrame(gameLoop);
}

async function startGame() {
    const name = playerNameInput.value.trim() || 'Player';
    localStorage.setItem('paperio_name', name);

    gamesPlayed++;
    localStorage.setItem('paperio_games', gamesPlayed);
    document.getElementById('games-played').textContent = gamesPlayed;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    CONFIG.botSpeed = CONFIG.speed * 0.875;

    initGridData();

    player = new Player();
    player.reset(name);

    createBots();

    camera.x = player.x - (canvas.width / 2) / CONFIG.zoom;
    camera.y = player.y - (canvas.height / 2) / CONFIG.zoom;

    overlay.style.display = 'none';
    scoreDisplay.style.display = 'block';
    leaderboard.style.display = 'block';
    minimap.style.display = 'block';
    ingameSettingsBtn.style.display = 'block';
    ingameSkinsBtn.style.display = 'flex';
    gameRunning = true;
    gamePaused = false;
    
    startAutoSave();
    
    await saveProgress('game_start');
}

window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    lastInputMethod = 'keyboard';
    
    if (e.key === 'Escape' && gameRunning) {
        gamePaused = !gamePaused;
        pauseOverlay.style.display = gamePaused ? 'flex' : 'none';
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

window.addEventListener('mousemove', (e) => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
    lastInputMethod = 'mouse';

    const dx = mousePos.x - lastMousePos.x;
    const dy = mousePos.y - lastMousePos.y;
    if (Math.hypot(dx, dy) > 2) {
        mouseMoving = true;
        lastMousePos.x = mousePos.x;
        lastMousePos.y = mousePos.y;
        if (mouseStopTimer) clearTimeout(mouseStopTimer);
        mouseStopTimer = setTimeout(() => { mouseMoving = false; }, 100);
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (!gameRunning) initMenuBackground();
});

startBtn.onclick = startGame;

playerNameInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') startGame();
});

async function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minimap.style.display = 'none';
    initMenuBackground();
    
    await initializeAuth();
    
    loadingOverlay.style.display = 'none';
    
    animateMenuBackground();
    gameLoop();
}

init();
    </script>
</body>
</html>
